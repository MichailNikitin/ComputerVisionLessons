import cv2
import numpy as np
import yaml
import os
from typing import List, Optional, Tuple, Dict, Any


class ArucoDetector:
    def __init__(self, config_yaml="aruco_config.yaml", calibration_npz="camera_calibration_good.npz"):
        """
        Инициализирует детектор ArUco с поддержкой:
        - размера маркера,
        - типа словаря,
        - параметров детектора,
        - сетки маркеров (для будущего использования),
        - калибровки камеры.
        """
        # === 1. Загрузка конфигурации из YAML ===
        if not os.path.exists(config_yaml):
            raise FileNotFoundError(f"Конфигурационный файл не найден: {config_yaml}")

        with open(config_yaml, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)

        self.marker_length = float(config.get('marker_length', 0.05))
        aruco_dict_name = config.get('aruco_dict', 'DICT_5X5_50')

        if not hasattr(cv2.aruco, aruco_dict_name):
            raise ValueError(f"Неизвестный словарь ArUco: {aruco_dict_name}")
        self.aruco_dict = cv2.aruco.getPredefinedDictionary(getattr(cv2.aruco, aruco_dict_name))

        # === 2. Загрузка параметров детектора ===
        self.detector_params = cv2.aruco.DetectorParameters()
        det_params_config = config.get('detector_params', {})
        for param_name, value in det_params_config.items():
            if hasattr(self.detector_params, param_name):
                setattr(self.detector_params, param_name, value)
            else:
                print(f"Предупреждение: неизвестный параметр детектора '{param_name}'")

        # === 3. Загрузка сетки (для будущего использования) ===
        self.grid = config.get('grid', {})
        self.grid_enabled = self.grid.get('enabled', False)

        # === 4. Загрузка калибровки камеры ===
        if not os.path.exists(calibration_npz):
            raise FileNotFoundError(f"Файл калибровки не найден: {calibration_npz}")

        with np.load(calibration_npz) as data:
            self.camera_matrix = data['camera_matrix'].astype(np.float32)
            self.dist_coeffs = data['dist_coeffs'].astype(np.float32)
            if self.dist_coeffs.ndim == 2:
                self.dist_coeffs = self.dist_coeffs.flatten()

        # === 5. Инициализация детектора ===
        self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.detector_params)

        # === 6. 3D модель одного маркера ===
        half = self.marker_length / 2
        self.marker_obj_points = np.array([
            [-half,  half, 0],
            [ half,  half, 0],
            [ half, -half, 0],
            [-half, -half, 0]
        ], dtype=np.float32)

        # === 7. Кэш последних поз ===
        self.last_pose: Dict[int, Tuple[np.ndarray, np.ndarray]] = {}

    def detect(self, image: np.ndarray) -> Tuple[List[np.ndarray], Optional[np.ndarray]]:
        if image is None or image.size == 0:
            return [], None
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        corners, ids, _ = self.detector.detectMarkers(gray)
        return corners, ids

    def estimate_pose(self, corners: List[np.ndarray], ids: Optional[np.ndarray]) -> Tuple[List[np.ndarray], List[np.ndarray]]:
        if ids is None or len(ids) == 0 or len(corners) != len(ids):
            return [], []

        rvecs, tvecs = [], []
        for corner in corners:
            img_points = corner.reshape((4, 2))
            success, rvec, tvec = cv2.solvePnP(
                self.marker_obj_points,
                img_points,
                self.camera_matrix,
                self.dist_coeffs,
                flags=cv2.SOLVEPNP_IPPE_SQUARE
            )
            if success:
                rvecs.append(rvec)
                tvecs.append(tvec)
            else:
                rvecs.append(np.zeros((3, 1), dtype=np.float32))
                tvecs.append(np.zeros((3, 1), dtype=np.float32))
        return rvecs, tvecs

    def get_pos(self, image: np.ndarray) -> Dict[int, Dict[str, Any]]:
        corners, ids = self.detect(image)
        rvecs, tvecs = self.estimate_pose(corners, ids)

        # Обновляем кэш только для текущих маркеров
        self.last_pose.clear()
        if ids is not None:
            for i, mid in enumerate(ids.flatten()):
                self.last_pose[int(mid)] = (rvecs[i].copy(), tvecs[i].copy())

        # Формируем результат
        pose_info = {}
        for marker_id, (rvec, tvec) in self.last_pose.items():
            tvec_flat = tvec.flatten()
            dist = np.linalg.norm(tvec_flat)
            rmat, _ = cv2.Rodrigues(rvec)
            pose_info[marker_id] = {
                'position': tvec_flat,
                'distance': dist,
                'rotation_vector': rvec.flatten(),
                'rotation_matrix': rmat,
                'translation_vector': tvec_flat
            }
        return pose_info

    def draw(self, image: np.ndarray, corners: List[np.ndarray], ids: Optional[np.ndarray],
             rvecs: List[np.ndarray], tvecs: List[np.ndarray]) -> np.ndarray:
        output = image.copy()
        if ids is not None:
            cv2.aruco.drawDetectedMarkers(output, corners, ids)

        if rvecs and tvecs and len(rvecs) == len(tvecs):
            for rvec, tvec in zip(rvecs, tvecs):
                if np.linalg.norm(tvec) > 1e-6:  # избегаем нулевых векторов
                    cv2.drawFrameAxes(
                        output,
                        self.camera_matrix,
                        self.dist_coeffs,
                        rvec,
                        tvec,
                        length=self.marker_length * 0.5
                    )
        return output
